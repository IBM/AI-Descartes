# Reasoning for Scientific Discovery

This repository contains the results and the code to run the experiments in the paper [AI Descartes: Combining Data and Theory for Derivable Scientific Discovery](https://arxiv.org/abs/2109.01634).

There are 2 main experiments pipelines (details below):
- [pipeline KeYmaeraX](#pipeline-keymaerax)
- [pipeline Mathematica](#pipeline-mathematica)


***
## Setup
* Download KeYmaeraX (4.9.3) from [here](https://keymaerax.org) and add it [here](src/keymaerax). 
* Install Matematica (Version: 12)
* Connect Matematica to KeYmaeraX, otherwise use `z3` (see KeYmaeraX website for more info)
* install the requirements in `src/requirements.txt`


***

## Pipeline KeYmaeraX
**Data location:** [reasoning/data/keymaera](data/keymaera)

There are 3 folders:
* `data/keymaera/input` containing the KeYmaera input files organized by the experiments (e.g. solar, binary starts, etc.)
* `data/keymaera/output` for the output files generated by KeYmaera organized by the experiments (e.g. solar, binary starts, etc.). This folder also contains the summary files for the different experiments. 
* `data/keymaera/final_results` has the results reported in the paper.

**Script location:** [src/pipeline_keymaera.py](src/pipeline_keymaera.py)

In the main function are available the following experiments:

### Unit-test
**Function:** `unittest.main()`

This function perform 3 tests: 2 test for KeYmaera, one using `z3` and one using `mathematica`; one test for the function `compute_output`

Run this to check that KeYmaera is well set up in your machine and that everything works properly.

### Direct run of KeYmaera
**Function:** `result = call_keymaera(file_name)`
**File:** `file_name = "test.kyx"`

Use this function to directly call KeYmaera for debugging purposes. It calls KeYmaera on a specific file (by default: `data/keymaera/input/test.kyx`).
You can check the output in the `result` object.

### Kepler
**Function:** `run_kepler()`

This runs the two predefined KeYmaera files for the Kepler problem:
*  `data/keymaera/input/Kepler.kyx`: regular Kepler (right formula)
*  `data/keymaera/input/Kepler_const.kyx`: Kepler with constants (right formula with constants)

The results are printed on the terminal.

### Langmuir
**Function:** `run_langmuir()`

This runs the three predefined KeYmaera files for the Langmuir problem:
*  `data/keymaera/input/langmuir.kyx`: regular Langmuir (right formula)
*  `data/keymaera/input/langmuir_const.kyx`: Langmuir with constants (right formula with constants)
*  `data/keymaera/input/langmuir_2sites.kyx`: Langmuir 2 sites (right formula with two sites)

The results are printed on the terminal.

### Feynman problems
**Function:** `run_feynman()`

This runs the three predefined files from AI-Feynman dataset:
*  `data/keymaera/input/Feynman_I_27_6.kyx`: for the Feynman problem Volume I Chapter 27 Equation 6
*  `data/keymaera/input/Feynman_I_16_6.kyx`: for the Feynman problem Volume I Chapter 16 Equation 6
*  `data/keymaera/input/Feynman_I_15_10.kyx`: for the Feynman problem Volume I Chapter 15 Equation 10

The results are printed on the terminal.

### Kepler Solar system
**Function:** `run_kepler_solar()`

This runt he experiments on the Solar system dataset. 
It will compute the following measures:
* `interval`: the interval reasoning metric
* `dependencies`: the dependencies of the non-target variables (IMPORTANT: to use this always compute the `interval` first)
* `pointwiseL2`: the l2 reasoning metric (point-wise)
* `pointwiseLinf`: the l_inf reasoning metric (point-wise) 
* `pointwiseLinf_efficient`: the l_inf reasoning metric (point-wise, and computed separately for each point) (IMPORTANT: to use this always compute the `pointwiseL2` first)
* `derivation`: try to derive the formula as it is (with the numerical constants)
* `weak_derivation`: try to derive the formula substituting the numerical constants with `c1, c2, ...`

**To change the measures** modify the global variable `MEASURES` at the beginning of the file.
The full list is:
```
MEASURES = ['interval', 'dependencies', 'pointwiseL2', 'pointwiseLinf', 'pointwiseLinf_efficient', 'derivation', 'weak_derivation']
```
IMPORTANT: 
* measure `dependencies` depends on measure `interval`
* measure `pointwiseLinf_efficient` depends on measure `pointwiseL2`
* the others are independent from each other.


**To change the precision level**  modify the global variable `PRECISION` at the beginning of the file.
By default it is set as `1e-4` which is `10^-4`. Do not set this lower then `1e-6`


**To change the input functions** add them as input in the function `run_kepler_solar()`.
The input format is the following:

``` formulas = [['formula1_keymaeraFormat','formula1_pythonFormat'], ... ,['formulaN_keymaeraFormat','formulaN_pythonFormat']]```

Thus `formulas` is a list of list of length 2, where the first element is a string containing the formula in KeYmaera format, while the second one is the same formula in python format.
For example
```
formulas = [['( 0.1319 * dN^3 )^(1/2)', 'sqrt( 0.1319 * dN**3 )'],
                ['( 0.1316 * ( dN^3 + dN ) )^(1/2)', 'sqrt( 0.1316 * ( dN**3 + dN ) )'],
                ['(( 0.03765 * dN^3 ) + dN^2 )/( 2.0 + dN )', '(( 0.03765 * dN**3 ) + dN**2 )/( 2.0 + dN )']]
```

IMPORTANT: 
* add spaces after each term (in particular for constant terms like `(X+0.2)` should be written as `( X + 0.2 )`
* for integer constants add .0 , for example (x+1) should be written as ( x + 1.0 )
* `formulas` is a list of lists. the innermost list are a pair of `[keymeara_formula, python_formula]` where `keymeara_formula` and `python_formula` represent the same formula in KeYmaera and python format respectively
* pay attention to:
  * power operator: KeYmaera `^` ;  python `**`
  * square root operator: KeYmaera `(expr)^(1/2)` ;  python `sqrt(expr)`

###  Kepler Exo-planets
**Function:** `run_kepler_exoplanets()`

Same as  for `run_kepler_solar()` but for Exo-planet dataset.

### Kepler Binary Stars
**Function:** `run_kepler_binarystars()`

Same as  for `run_kepler_solar()` but for Binary star dataset.

### Kepler counterexamples
**Function:** `run_kepler_solar_counterexample()`

This function generate counterexamples (assignment of the variable of interest PN) for a specific input non derivable formula for the solar system dataset for Kepler.
To change the input points do it directly in the function `run_kepler_solar_counterexample` and modify `data_points` dictionary.

* **input:** assignment of the variables `m1N`, `m2N`, `dN`, e.g. `data_points = {'m1N': 1, 'm2N': 0.055, 'dN': 0.3871}`
* **output:** value of `PN`

***

## Pipeline Mathematica

**Data location**: `data/wolfram`

**Script location**: `src/pipeline_mathematica.py`

In the main function are available the following experiments:

### Unit-Test
**Function:** `unittest.main()`


This function perform 3 tests to make sure Mathematica is working properly.
Run this to check that Mathematica is well set up in your machine and that everything works properly.


###  Direct run Mathematica
**Function:** `call_wolfram()`

Use this function to directly call Mathematica for debugging purposes. It calls Mathematica on a specific file and formula.
For example:
```
call_wolfram('Limit[1/x,x->Infinity]<Infinity', file_name='test')
```
will try to prove that the limit of `1/x` at infinity is not infinity.

If the `debug` flag is set to `True` then output can be found in `data/wolfram/output/`

### Test functions 1 variable
**Function:** `test1()`
Perform a test trying the axioms in `data/wolfram/input/axioms1.txt` over the formulas in `data/wolfram/input/formulas1.txt`. This example does a check for unary functions. 



### Test functions 2 variable
**Function:** `test2()`

Perform a test trying the axioms in `data/wolfram/input/axioms2.txt` over the formulas in `data/wolfram/input/formulas2.txt`. This example does a check for binary functions. 

### Langmuir
**Function:** `langmuir()`

This function will run the experiments regarding Langmuir.

* Write the formulas to check in the file: `data/wolfram/input/formulas_langmuir.txt`
* Write the axioms to apply in the file = `data/wolfram/input/axioms_langmuir.txt`

The output can be found at: `data/wolfram/output/wolfram_results_formulas_langmuir.txt`

In general the function `preprecess_pipeline(formulas_file, axioms_file, debug=True)` allows you to perform the check using the axioms
in `data/wolfram/input/axioms_file` over the formulas in `data/wolfram/input/formulas_file`.

**How to format Axioms and Formulas**:
* The axioms has to be formatted in Wolfram Language one per line
* The formulas has to be formatted in Wolfram Language one per line
* To assign a variable in the formula to a specific number write: `axiom    var1->number1   var2->number2 ...` each separated by a tab. For example if I want to check if the function `f(x,y)` is equal to `0.2` when `x=5` and `y=5` I write `f(x,y)==0.2	x->5    y->5`.
* IMPORTANT in the formulas file the first line should contain the function specification writing:
`function	f(x)` for unary function and `function	f(x,y)` for binary etc. You can find more example in the `data/wolfram/input` folder.
Use a tab separator between the keyword `function` and the function form.
The function has to be called `f(..)` with any number arguments. 
Be consistent between the name of the variables in the function file and the axioms file.
* In the formulas files you can comment lines using the `#` character at the beginning of the line
* Write all the numbers in form of fractions: e.g. `0.00345` should be written as `(345/100000)`.

***



